(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{ugw8:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return d}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("q1tI");var a=n("7ljp"),r=n("013z");n("qKvR");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var i={},s={_frontmatter:i},c=r.a;function d(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(c,o({},s,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Introduction"),Object(a.b)("p",null,"One of the use cases in our ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/"}),"Reefer Container Shipment reference application")," for ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/"}),"Event Driven Architectures"),", consist of users (customers of the shipment company) having the ability to create a new order to get their fresh goods shipped overseas from an origin port to a destination port. Customers can also update and reject previously created orders but the mechanism whereby an action from a customer is attended and processed by our reference application is the same regardless of whether it is a new order creation or an update/rejection of a previously created order. Therefore, for the sake of clarity we will refer to new order creation in this documentation."),Object(a.b)("p",null,"In this readme, we are going to focus on how we can ensure that any action requested by the user of our application is attended and processed in an Event Driven application by making use of the different mechanisms, patterns and best practices for such type of architectural design."),Object(a.b)("h2",null,"Goal"),Object(a.b)("p",null,"In a nutshell, we want to implement a component, which will be a microservice, in our Reefer Container Shipment reference application to manage the orders. As part of its responsibilities, it will listen/receive commands to create (update and reject as well) new orders from a user/customer."),Object(a.b)("p",null,"The order creation process consists of:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Create")," an ",Object(a.b)("em",{parentName:"li"},"Order")," object that holds the order information provided by the user/customer (that is, customer id, product id, origin Port, destination port, quantity, etc) along with a unique identifier for the order"),Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Save")," the order in a database which will serve to hold the current status for the orders."),Object(a.b)("li",{parentName:"ol"},"As in any Event Driven application, we want to ",Object(a.b)("strong",{parentName:"li"},"publish")," a new order created event so that any other interested parties in your overall solution get notified on this change to system. For instance, in our reference application, this will trigger a long running transaction for finding a container and a voyage to allocate an assign for the proper delivery of the customer’s fresh goods. You can read more about this long running transaction process and the ",Object(a.b)("a",o({parentName:"li"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/design-patterns/saga/"}),"SAGA pattern")," implementation of it ",Object(a.b)("a",o({parentName:"li"},{href:"../saga/saga.md"}),"here"))),Object(a.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1024px"}},"\n      ",Object(a.b)("span",o({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"56.25%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAvXAAAL1wElddLwAAABV0lEQVQoz6WSQUsCQRTH/VJdunpQKKgguvQBOnSTBEnDQx+gDxAFnTrUoVMgEcXWOlqGlqaV7YqJS667m7u6MzvOztToqpiklx7/GebP48d7M2983/8I38ws48vG1lX59Kku9j2bBTPG+rsnD+4I0lmpce/BjP2GPc+G9B8NUC5GXUwpmaxMGTMcwilNN5pNtWFAMa8JOTVd1O+KOnjWhaySAHJClC5S1Y8GHJXowbUOXr+pmth1CeX28LyyHAV7J2/BsMi1GAELEeAPif5Qcm7jOrpf8OoNYNlE8ayiIYKgQwk6vqwtbSdjB4Vg+HYlBtbi6dWdVCAsBraS85vC7tFrD6Zs8sEcjB0ETZtky1+ZF6Mgm49Siyv33sqU1IfSJ8grUk1zSXfswYaaHhTaFkYW7dr8ACGcOmd+Hd7VSNwqdUWWK22rPTGN2Z9k0A5CqKnpbCy87A+oWmNDFDzGJgAAAABJRU5ErkJggg==')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(a.b)("img",o({parentName:"span"},{className:"gatsby-resp-image-image",alt:"objective",title:"objective",src:"/refarch-kc/static/0be63596347043ce7d6c7276a8f46d5a/2faef/Slide1.png",srcSet:["/refarch-kc/static/0be63596347043ce7d6c7276a8f46d5a/7fc1e/Slide1.png 288w","/refarch-kc/static/0be63596347043ce7d6c7276a8f46d5a/a5df1/Slide1.png 576w","/refarch-kc/static/0be63596347043ce7d6c7276a8f46d5a/2faef/Slide1.png 1024w"],sizes:"(max-width: 1024px) 100vw, 1024px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(a.b)("p",null,"Implementing the process described above is not as simple as it could sound at first. In order to successfully attend, process and mark any new order creation request from any given customer, we must ensure that the order object created is persisted into a database and an event is published to an ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/evt-backbone/"}),"event backbone")," such as ",Object(a.b)("a",o({parentName:"p"},{href:"https://kafka.apache.org/"}),"Kafka")," or ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.ibm.com/cloud/event-streams"}),"IBM Event Streams")," as a result. In other words, we need to execute those two actions in a transaction-like fashion: ",Object(a.b)("strong",{parentName:"p"},"either both or none of them happen"),"."),Object(a.b)("p",null,"Not only that but we would also like to build our Order component/microservice in a way that it ",Object(a.b)("strong",{parentName:"p"},"automatically retries")," the create new order process if anything goes wrong, without needing any customer interaction. That is, we would like to build our Order component/microservice in a way that once it receives a new order creation request from a customer, it will automatically retry the transaction-like process over and over until it is successfully completed."),Object(a.b)("h3",null,"Database"),Object(a.b)("p",null,"We are not going to cover how database transactions in Software Engineering work because it is a huge field to talk, research and learn about and that is out of the scope of this work. The internet is already plenty of this type of literature in case you want to gain some understanding. Instead, we are going to rely on the transactional capabilities of databases in general so that we will rely on the database to properly store our order object in it or not store anything at all."),Object(a.b)("h3",null,"Kafka"),Object(a.b)("p",null,"For Kafka, we provide a lot of content on the key Kafka concepts ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/kafka/readme/"}),"here")," and architecture considerations ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/kafka/arch/"}),"here")," for a good understanding of what the basics components of Kafka are (such as topic, partition, consumer, producer, etc) and the characteristics of Kafka (such as its high availability and resiliency)."),Object(a.b)("p",null,"Once we understand the above, we still need to dive a bit deeper into Kafka and its technology in order to understand how Kafka provides ",Object(a.b)("strong",{parentName:"p"},"exactly-once message delivery"),", which is what we need to implement/ensure for the second action in our create new order process. We strongly recommend you going through the following links for a full understanding of the Kafka capabilities (such as idempotence, transactions, acknowledgements, etc) that makes developers available with in order to solve complex problems:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Kafka Message Delivery semantics in the Apache Kafka documentation ",Object(a.b)("a",o({parentName:"li"},{href:"https://kafka.apache.org/documentation/#semantics"}),"here"),"."),Object(a.b)("li",{parentName:"ul"},"Exactly-once Support in Apache Kafka by Jay Kreps, Co-Creator of Apache Kafka ",Object(a.b)("a",o({parentName:"li"},{href:"https://medium.com/@jaykreps/exactly-once-support-in-apache-kafka-55e1fdd0a35f"}),"here"),"."),Object(a.b)("li",{parentName:"ul"},"Transactions in Apache Kafka Confluent blog by Apurva Mehta and Jason Gustafson ",Object(a.b)("a",o({parentName:"li"},{href:"https://www.confluent.io/blog/transactions-apache-kafka/"}),"here"),"."),Object(a.b)("li",{parentName:"ul"},"Our ",Object(a.b)("a",o({parentName:"li"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/kafka/producers/"}),"Producer")," and ",Object(a.b)("a",o({parentName:"li"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/kafka/consumers/"}),"consumer")," considerations.")),Object(a.b)("h2",null,"Solution"),Object(a.b)("h3",null,"Methodology"),Object(a.b)("p",null,"We have designed our Reefer Container Shipment reference application by combining some elements of the ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.ibm.com/garage/method/practices/think/enterprise-design-thinking"}),"design thinking")," methodology with the ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/methodology/eventstorming/"}),"Event Storming")," and ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/methodology/ddd/"}),"Domain Driven Design"),"."),Object(a.b)("p",null,"Thanks to the Event Storming work we specifically did for our Reefer Container Shipment business domain (see it ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-kc/analysis/readme/"}),"here"),"), we were able to identify things like the ",Object(a.b)("strong",{parentName:"p"},"events and commands")," that will flow through our system as well as the domains, subdomains, contexts, etc that will help us identify what microservices/components we should build."),Object(a.b)("p",null,"We also wanted to implement one of the most common Event Driven patterns called ",Object(a.b)("a",o({parentName:"p"},{href:"https://ibm-cloud-architecture.github.io/refarch-eda/design-patterns/event-sourcing/"}),"Event Sourcing")," which dictates to ",Object(a.b)("strong",{parentName:"p"},"capture all changes to an application state as a sequence of events"),"."),Object(a.b)("h4",null,"Events and Commands"),Object(a.b)("p",null,"From Martin Fowler’s Event Sourcing:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"In this discussion I refer to encapsulating all changes to an application state through events, I could easily state all of this using the word (and pattern) ‘Command’. Events clearly share most of the properties of commands - the ability to have their own lifetime, to be queued and executed, event reversal is the same as command undo."),Object(a.b)("p",{parentName:"blockquote"},"One reason for using event is that the term is as widely used in the field for this kind of behavior. It’s common hear terms such as event driven architecture and Event Message."),Object(a.b)("p",{parentName:"blockquote"},"In the end I went with event because I think there’s a subtle, but important set of associations that come with it. People think of a command as encapsulating a request - with a command you tell a system to do X. Events, however, just communicate that something happened - with an event you let a system know that Y has happened. Another difference is that you think of broadcasting events to everyone who may be interested but sending commands only the a specific receiver. When it comes to actual behavior it doesn’t really matter. The polymorphic reaction of a system to an X command need be no different to a Y event. Yet I think the naming does affect how people think about events and what kind of events they create."),Object(a.b)("p",{parentName:"blockquote"},"You should also look at the contrast between ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.enterpriseintegrationpatterns.com/patterns/messaging/CommandMessage.html"}),"Command Message")," and ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.enterpriseintegrationpatterns.com/patterns/messaging/EventMessage.html"}),"Event Message"),".")),Object(a.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"854px"}},"\n      ",Object(a.b)("span",o({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"51.041666666666664%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAACiElEQVQozz2Su2sUURSHp/AvsNTWRoKSxiZoJRYqpBNRNJUiGLAwjcYUFpFAkChqfIGPQECFaDQhhGzCyhrzTtydfczcubOzj8zu7O7sM1GIaPF5d6MWwxkOd7459/w+rVS8z86PToreM8r+TRr1C7jua1W7qFS6EZaBaVkYpiBh7D5CCNUTlJwcZdujnCxQcFxMYaKtRm8QWD1AxOgnIbsQqQ4FvI9uHSW12UlagZLxJKaqpvgLi1sIBa6nSvgJj6ooUksXd4G9T3TaL31j4JXOlcEoV+/G+boiOX49wsNRiR+SZGct0iKJYZlkhENuziIXsrHNJFLaSMvGUrdo/kybmY/z6pNOcDHByITO6JTOhm5y702Y2ZBBYcHGnVcfG02gYFMqYFDifkmStJKtqVtrUMAmVKuEe9kOHaEa66exfIbG4mnysRf8XD7G1tp5MhsPqAfbKKz2kAsPUZo5THH9NuWVbqpzh8hFn1NcuEg12E46MY3mh06SH9WoLp+lNLmX0vge/PAttj5q1AP7Kaz1sD2uUVk4qd6v4aqz/uI5aqEOamMaJb2Pwkwbtfca2dhbtEx8DC8ySCYx0ZrMjb5U11vEiw7jxl7jGEE8/THe2iS59SD58BNSapJM/IOCPcWPLlPRx8lHnyLNdTRDlIlbv4gZRcKJLLYIq8V/VlqkMWRe7c1BihLZQAZ3Nq325qteShmRUQb45KYdvAUPaauUVThaPt/H752DfAje4fJAmMi7g3yf1HAjjzClq5KL4ygdUksGzpKqLXXMlp8pFUZhxSG/oUJTBrRSzm4OsVU/xdT8MDeGY8QmTtAI7COrj7SAljBaB4VsJrnr4T9FmslKW2JJ63//DyCIlPIE2iOgAAAAAElFTkSuQmCC')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(a.b)("img",o({parentName:"span"},{className:"gatsby-resp-image-image",alt:"eventStorming",title:"eventStorming",src:"/refarch-kc/static/ee86ed2fc9c173b0c606a26fc66d41e6/f8087/ship-dom-cmd1.2.png",srcSet:["/refarch-kc/static/ee86ed2fc9c173b0c606a26fc66d41e6/7fc1e/ship-dom-cmd1.2.png 288w","/refarch-kc/static/ee86ed2fc9c173b0c606a26fc66d41e6/a5df1/ship-dom-cmd1.2.png 576w","/refarch-kc/static/ee86ed2fc9c173b0c606a26fc66d41e6/f8087/ship-dom-cmd1.2.png 854w"],sizes:"(max-width: 854px) 100vw, 854px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(a.b)("h3",null,"Order Commands"),Object(a.b)("p",null,"Based on the Event Storming exercise, we were able not only to identify the events that will occur but also the commands (among many other outcomes such as actors, domain entities, policies, etc). In the small domain we are focused on in this piece of documentation, we will have three commands:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create order."),Object(a.b)("li",{parentName:"ul"},"Update order."),Object(a.b)("li",{parentName:"ul"},"Reject order.")),Object(a.b)("p",null,"and three events as a result:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"OrderCreated."),Object(a.b)("li",{parentName:"ul"},"OrderUpdated."),Object(a.b)("li",{parentName:"ul"},"OrderRejected.")),Object(a.b)("p",null,"Combining the commands concept and the Event Sourcing pattern, which consist of capturing all the changes to our application as a sequence of events, we have decided to create a new topic in our event backbone (either Kafka or IBM Event Streams) called ",Object(a.b)("strong",{parentName:"p"},"order-commands")," where the requests from our Reefer Container Shipment customers will end up as a command for the application to process and execute."),Object(a.b)("p",null,"The interaction between a customer and the system to get a new order created will now consist of just our Order component creating a unique identifier for the new order and logging a command for such new order creation with the customer’s request information (customer id, product id, quantity, origin, destination, etc) and the order unique identifier (1, 2 and 3 in the picture above)"),Object(a.b)("p",null,"The actual creation of the order, that is, creating the order object, saving it to the database and publishing an event as a result to the orders topic for any interested component within our overall application (4, 5 and 6 in the picture above) will be dealt asynchronously by the Order component/microservice guaranteeing the complete processing of all those actions by using the consume-transform-produce loop pattern we will see next."),Object(a.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1024px"}},"\n      ",Object(a.b)("span",o({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"56.25%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAvXAAAL1wElddLwAAABiklEQVQoz6VSv0vDQBT2v3IQQQcHUXBwVASdHBQFxeIiohT9C9wFcXF0cChY2tBWYqlRK21t7a/Y2iaaXnL5cZe7S7xI1CJFBx/v3vDxfe++e++G/H/E0J8Mz/N4fQaVWOm0rVcDxPcGiL0w/P5kLKC2QO2yfNaF8k/xR+uw/mrB9xlFyCGEfouZ5/UQoYyp6qumaXdPICEpwq0q3Kmx6048pyQlNX6jXGQa54lHuaUSF3+LZRPPCXUdEUaoDu2lw+zwcnx0NTG2ljw4KSxExfF1YTqSnopkRlaEVP6VSyhlobiqO7tSW0PERRiazuZRfmIjNRVJz2xf7R0XFg9zszvifDQ7v389uZUWC1pg9mMQnwPzmG1Z3HZP02rP2n3lrdgAtyVFzLdvil2p1H2ocsS4LyuAe7M516KUhmKXUgAAhyCEyDGxYzGKsWNSzNMm2PIZp7im0YOGrhv86K7rDt7zy0vnqVLhvb72jBCu1xuyLBNCBnyScMXBe1inqzabLQjNfhyA4M5+5B1cUV/cJGO+PQAAAABJRU5ErkJggg==')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(a.b)("img",o({parentName:"span"},{className:"gatsby-resp-image-image",alt:"orderCommand",title:"orderCommand",src:"/refarch-kc/static/710eb49b8f9cf48718015359bb639196/2faef/Slide2.png",srcSet:["/refarch-kc/static/710eb49b8f9cf48718015359bb639196/7fc1e/Slide2.png 288w","/refarch-kc/static/710eb49b8f9cf48718015359bb639196/a5df1/Slide2.png 576w","/refarch-kc/static/710eb49b8f9cf48718015359bb639196/2faef/Slide2.png 1024w"],sizes:"(max-width: 1024px) 100vw, 1024px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(a.b)("p",null,"Having requests from your application users logged as commands in a topic in your event backbone for you Event Driven application has the following advantages:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Event Sourcing")," - Implements the Event Sourcing pattern for Event Driven applications. That is, any change/action to be carried out that might change your system status is logged so that the current or past statuses can be achieved by replaying the commands and events."),Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Asynchronous")," - By logging the request to a topic as an action for the system to perform, we move towards a more asynchronous and less blocking action processing methodology that allow user interaction with the system for requests shorter and less prone to fail."),Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Parallelism")," - If a request from a customer needed to trigger another process than the new order creation in the Order microservice/component, by logging the action to a topic where any other application component can subscribe to we are enabling processes to be parallelized."),Object(a.b)("li",{parentName:"ol"},Object(a.b)("strong",{parentName:"li"},"Automation")," - Having customers’ requests logged in a topic in our event backbone as commands to be processed and executed by our system, allows us to build our system in such a way that it will automatically retry such commands processing over and over without needing customer interaction until the requests have been successfully completed end-to-end. ")),Object(a.b)("p",null,"The interaction between a customer and the system to get a new order created will now consist of just our Order component creating a unique identifier for the new order and logging a command for such new order creation with the customer’s request information (customer id, product id, quantity, origin, destination, etc) and the order unique identifier (1, 2 and 3 in the picture above)"),Object(a.b)("p",null,"The actual creation of the order, that is, creating the order object, saving it to the database and publishing an event as a result to the orders topic for any interested component within our overall application (4, 5 and 6 in the picture above) will be dealt asynchronously by the Order component/microservice guaranteeing the complete processing of all those actions by using the consume-transform-produce loop pattern we will see next."),Object(a.b)("h3",null,"Consume-transform-produce Loop"),Object(a.b)("p",null,"As already mentioned in this readme, our Order component/microservice will be responsible for taking in requests from our Reefer Container Shipment customers and satisfy those. For the sake of simplicity, we have focused on the create new order request. We have already said that this request will consist of creating an order object, persisting such order object into a database and publishing an event accordingly to the orders topic, but it could consist of many more actions. Because we want to ensure that requests from our customers are attended, processed and executed successfully but errors might happen and we want to avoid long blocking requests, we have introduced in the previous section, the concept of logging customer requests as commands in a topic in our event backbone (A in the picture below)."),Object(a.b)("p",null,"Therefore, the most critical part of the Order component/microservice is now the processing of those commands published in the order-command topic of our event backbone that correspond to customer requests. We want to be able to successfully process all of them regardless of how many actions these entail, making sure these actions are all executed and we get confirmation of those. We want to process these actions in a transaction-like manner so that a request is not successfully marked as processed unless all actions were successfully executed (B in the picture below)."),Object(a.b)("span",{className:"gatsby-resp-image-wrapper",style:{position:"relative",display:"block",marginLeft:"auto",marginRight:"auto",maxWidth:"1024px"}},"\n      ",Object(a.b)("span",o({parentName:"span"},{className:"gatsby-resp-image-background-image",style:{paddingBottom:"56.25%",position:"relative",bottom:"0",left:"0",backgroundImage:"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAvXAAAL1wElddLwAAAB/UlEQVQoz22SS2/TQBDH+7mQQEKIAwg4cAUBZxAvIZBy4ICKgCOCD0DFu0i5tFFbHmrThDzaQEzesb0xtteO7Tzs+LHexF673aZFAZHVX6PRaH6andF/YW/ei+OYxrdfpNsvfvHQdVAwtEPLjYPgn7aFOeQ0Wk6QZnorObXSsTiIi1xttfamDtm/WqbwdMweGpOXSb7asWji+qFujoHiSTriocMruASaqfrHmgym4H+wYY7XdgwG2ELXEzRPHWCaUFik0pCkYVb0RNXBGBNCZjCJYicguonLTcg0lbWCtrwJk9vKpy34ekN8/1Ve3pQ/fJNfpbillYak9sNgMoOhN7mSk4DhNTpmme1fflw6dn37xK3MyTuZZ+/aV5+UTt3Nnk/kzyWKx29mc/XBwTwSHcHCyF+saqyBavywwg1uPK+evpc7+yB/IVF8tNS69rR88eHupcUS1Zn7+d2WSZEoiv/sfPCFCGpWnhF/1GH6p7JegOmynvouJbc6q5nfqay4XlA2dvTPRdkaudj3PYTo5kdwFBMg9Zi2XuGMOtBbQk9UrCYwWgJVr9kxADQBtNpC17Ztx3FoDIJgdm3TDVno8SriFNTmIc8BThpyis9CWvHbktVoAUGQwzCcYxJ6AzQOEQ5dFChdA0J1aDr+hNAKwsQfE6NvjWz30H+HFtwHnnhF/unL1y0AAAAASUVORK5CYII=')",backgroundSize:"cover",display:"block"}})),"\n  ",Object(a.b)("img",o({parentName:"span"},{className:"gatsby-resp-image-image",alt:"actions",title:"actions",src:"/refarch-kc/static/3dafb437d33a652a8eb642a27191955e/2faef/Slide3.png",srcSet:["/refarch-kc/static/3dafb437d33a652a8eb642a27191955e/7fc1e/Slide3.png 288w","/refarch-kc/static/3dafb437d33a652a8eb642a27191955e/a5df1/Slide3.png 576w","/refarch-kc/static/3dafb437d33a652a8eb642a27191955e/2faef/Slide3.png 1024w"],sizes:"(max-width: 1024px) 100vw, 1024px",style:{width:"100%",height:"100%",margin:"0",verticalAlign:"middle",position:"absolute",top:"0",left:"0"},loading:"lazy"})),"\n    "),Object(a.b)("p",null,"As you should already know by now if you read the ",Object(a.b)("a",o({parentName:"p"},{href:"#kafka"}),"Kafka")," section in this readme in depth, is that with the introduction of the concepts of ",Object(a.b)("strong",{parentName:"p"},"idempotence")," and ",Object(a.b)("strong",{parentName:"p"},"transactions")," in Kafka 0.11 we can now execute transformations over an event consumed from Kafka and produce an event as the output to Kafka in a transaction-like manner. This is known as the consume-transform-produce loop pattern."),Object(a.b)("p",null,"The key of this loop is that the produced event to the orders topic as the last action of the request (so that all previous actions have successfully been executed already) will be produced along with the offset commitment for the command read as a transaction. That is, either both the event to the orders topic is produced and the offset for the command read from the order-command topic is committed or none of them happen. This allows us to only mark a request completed, that is get his offset in the order-commands topic committed, only if all the actions for such request have been already successfully executed and the resulting event is published into the orders topic."),Object(a.b)("p",null,"If anything happens in between for any of the other actions that entail a request such as network failures, timeouts, etc the transaction will not be committed by Kafka which means the command offset in the order-command topic does not get committed and the request itself will get reprocessed event if the Order component/microservice gets killed/restarted."),Object(a.b)("h2",null,"Implementation"),Object(a.b)("p",null,"In this section, we are going to look at the specifics of our implementation for the two main actions, A and B, described in the picture above. The Order component/microservice is implemented in Java using MicroProfile and running on the Open Liberty server."),Object(a.b)("h3",null,"A - Order Commands"),Object(a.b)("p",null,"The Order component/microservice exposes a REST resource for customers to request a new order creation that will create the order object with a random unique identifier and pass that on to the REST service:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'@POST\n@Consumes(MediaType.APPLICATION_JSON)\n@Produces(MediaType.APPLICATION_JSON)\n@Operation(summary = "Request to create an order", description = "")\n@APIResponses(value = {\n        @APIResponse(responseCode = "400", description = "Bad create order request", content = @Content(mediaType = "text/plain")),\n        @APIResponse(responseCode = "200", description = "Order created, return order unique identifier", content = @Content(mediaType = "text/plain")) })\npublic Response createShippingOrder(ShippingOrderCreateParameters orderParameters) {\n    // ... validate input data ...\n    ShippingOrder order = ShippingOrderFactory.createNewShippingOrder(orderParameters);\n    try {\n        shippingOrderService.createOrder(order);\n    } catch(Exception e) {\n        return Response.serverError().build();\n    }\n    return Response.ok().entity(order).build();\n}\n')),Object(a.b)("p",null,"The REST service will create the ",Object(a.b)("em",{parentName:"p"},"OrderCommandEvent")," out of the order from the REST resource and call the Order Command Producer to emit the ",Object(a.b)("em",{parentName:"p"},"OrderCommandEvent")," to the order-command topic:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'public void createOrder(ShippingOrder order) throws OrderCreationException {\n    OrderCommandEvent createOrderCommandEvent = new OrderCommandEvent(System.currentTimeMillis(), KafkaInfrastructureConfig.SCHEMA_VERSION, order, OrderCommandEvent,TYPE_CREATE_ORDER);\n    try {\n        emitter.emit(createOrderCommandEvent);\n    } catch (Exception e) {\n        emitter.safeClose();\n        throw new OrderCreationException("Error while emitting create order command event");\n    }\n}\n')),Object(a.b)("p",null,"The Order Command Producer will emit the event:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),"@Override\n@Retry(retryOn=TimeoutException.class,\n    maxRetries = 4,\n    maxDuration = 10000,\n    delay = 200,\n    jitter = 100,\n    abortOn=InterruptedException.class)\n@Timeout(4000)\npublic void emit(OrderEventBase event) throws Exception {\n    if (kafkaProducer == null) initProducer();\n\n    OrderCommandEvent orderCommandEvent = (OrderCommandEvent)event;\n    String key = ((ShippingOrder)orderCommandEvent.getPayload()).getOrderID();\n    String value = new Gson().toJson(orderCommandEvent);\n\n    try {\n        ProducerRecord<String, String> record = new ProducerRecord<>(KafkaInfrastructureConfig.getOrderCommandTopic(), key, value);\n        Future<RecordMetadata> send = kafkaProducer.send(record);\n        send.get(KafkaInfrastructureConfig.PRODUCER_TIMEOUT_SECS, TimeUnit.SECONDS);\n    } catch (KafkaException e){\n        logger.error(e.getMessage());\n        throw new KafkaException(e);\n    }\n}\n")),Object(a.b)("p",null,"The Order Command Producer is enabled for idempotence (so that events are delivered exactly-once) and waits for the acknowledgment of all kafka brokers to ensure the message is HA and resilient:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'private void initProducer() {\n    properties = KafkaInfrastructureConfig.getProducerProperties("ordercmd-command-producer");\n    properties.put(ProducerConfig.ACKS_CONFIG, "all");\n    properties.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);\n    kafkaProducer = new KafkaProducer<String, String>(properties);\n}\n')),Object(a.b)("p",null,"With the above implementation, customers will get notified if anything goes wrong during the process of receiving a new order creation request and the production of the OrderCommandEvent as a result. If any exception, timeout, etc with Kafka happens, the Order Command Producer will retry and if that still does not work, the REST service will return a server error, as a result of the exception thrown by the Order Command Producer, so that the customer is informed in order to try again. If the Order component itself fails at some point for whatever reason, when the customer gets into the create new order webpage, they will get listed their orders so that he can decide whether the last one went through before the Order component failed or he needs to create it again instead."),Object(a.b)("h3",null,"B - Consume-transform-produce Loop"),Object(a.b)("p",null,"The implementation for the consume-transform-produce loop is based on the ",Object(a.b)("a",o({parentName:"p"},{href:"https://www.baeldung.com/kafka-exactly-once"}),"Exactly Once Processing in Kafka")," by Baeldung."),Object(a.b)("p",null,"Here we start with the Order Command Runner that will keep polling the order-command topic through the Order Command Agent:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),"@Override\npublic void run() {\n    OrderCommandAgent orderCommandAgent = new OrderCommandAgent();\n    try {\n        while (running && orderCommandAgent.isRunning()) {\n            try {\n                // poll for OrderCommandEvent events from the order-commands topic\n                orderCommandAgent.poll();\n            } catch (KafkaException ke) {\n                // Treat a Kafka exception as unrecoverable\n                // stop this task and queue a new one\n                running = false;\n            }\n        }\n    } finally {\n        orderCommandAgent.safeClose();  \n    }\n}\n")),Object(a.b)("p",null,"where the Order Command Agent will retrieve records from the order-command topic (that are customer requests) and, for each of them, it will deserialize the record, calculate the offset for the record and partition to be committed to (in case everything goes fine) and call a handle function for further processing of the request"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),"public void poll() {\n    // Get records from the order-command topic.\n    // The kafka consumer poll api ensures liveness. The consumer sends periodic heartbeats to the server.\n    ConsumerRecords<String, String> recs = this.orderCommandsConsumer.poll(this.pollTimeOut);\n    for (ConsumerRecord<String, String> rec : recs) {\n        // -- Deserialize the record.\n        OrderCommandEvent event = OrderCommandEvent.deserialize(rec.value());\n        // -- Calculate the offset to commit as part of the transaction\n        Map<TopicPartition, OffsetAndMetadata> offsetsToCommit = new HashMap<>();\n        TopicPartition partition = new TopicPartition(KafkaInfrastructureConfig.getOrderCommandTopic(),rec.partition());\n        OffsetAndMetadata oam = new OffsetAndMetadata(rec.offset()+1);\n        offsetsToCommit.put(partition,oam);\n        // -- Initiate processing of the command\n        handleTransaction(event,offsetsToCommit);\n    }\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"IMPORTANT:")," The Order Command Consumer is configured to not auto commit offsets as this has to be done by the Order Event Producer as part of a transaction:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'Properties properties = buildCommonProperties();\n\nproperties.put(ConsumerConfig.GROUP_ID_CONFIG, "ordercmd-command-consumer-grp");\nproperties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.toString(false));\nproperties.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");\nproperties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\nproperties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());\nproperties.put(ConsumerConfig.CLIENT_ID_CONFIG, "ordercmd-command-consumer");\n// Using a value of read_committed ensures that we don\'t read any transactional messages before the transaction completes.\nproperties.put(ConsumerConfig.ISOLATION_LEVEL_CONFIG, "read_committed");\n\nthis.orderCommandsConsumer = new KafkaConsumer<String, String>(properties);\n\n')),Object(a.b)("p",null,"The handle function will process the request based on whether it is a order creation, update or rejection:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'@Override\npublic void handleTransaction(OrderEventBase event,Map<TopicPartition, OffsetAndMetadata> offsetToCommit) {\n\n    OrderCommandEvent commandEvent = (OrderCommandEvent) event;\n    logger.info("handle command event : " + commandEvent.getType());\n\n    switch (commandEvent.getType()) {\n    case OrderCommandEvent.TYPE_CREATE_ORDER:\n        processOrderCreation(commandEvent,offsetToCommit);\n        break;\n    case OrderCommandEvent.TYPE_UPDATE_ORDER:\n        processOrderUpdate(commandEvent,offsetToCommit);\n        break;\n    case OrderCommandEvent.TYPE_REJECT_ORDER:\n        processOrderRejection(commandEvent,offsetToCommit);\n        break;\n    }\n}\n')),Object(a.b)("p",null,"Here we get to the main method that will create the order object, persist it into the database and produce an OrderCreated event to be then sent the orders topic by the Order Event Producer:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),'private void processOrderCreation(OrderCommandEvent commandEvent,Map<TopicPartition, OffsetAndMetadata> offsetToCommit) {\n    // Create the order object\n    ShippingOrder shippingOrder = (ShippingOrder) commandEvent.getPayload();\n    // Set the status on the shippingOrder to PENDING\n    shippingOrder.setStatus(ShippingOrder.PENDING_STATUS);\n    try {\n        // SAVE the newly created order into the DB.\n        // This action MUST support repetition given that the order creation process might get repeated\n        // if all the actions to perform do not succeed.\n        orderRepository.addOrUpdateNewShippingOrder(shippingOrder);\n    } catch (OrderCreationException e) {\n        // need other components to fix this save operation: CLI / human or automatic process\n        generateErrorEvent(shippingOrder,offsetToCommit);\n        return;\n    }\n    // Create the event to be sent to the orders topic\n    OrderEvent orderCreatedEvent = new OrderEvent(new Date().getTime(),OrderEvent.TYPE_ORDER_CREATED,schemaVersion,shippingOrder.toShippingOrderPayload());\n    try {\n        // Emit the event and consumer offsets as a transaction\n        orderEventProducer.emitWithOffsets(orderCreatedEvent,offsetToCommit,"ordercmd-command-consumer-grp");\n    } catch (Exception e) {\n        // the order is in the repository but the app could not send to event backbone\n        // consider communication with backbone as major issue\n        e.printStackTrace();\n        running = false; // liveness may kill this app and restart it\n        return ;\n    }\n}\n')),Object(a.b)("p",null,"Finally, the Order Event Producer will be in charge of sending the OrderCreated event to the orders topic as well as committing the offset for the record read and processed from the order-commands topic, both as a transaction:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-Java"}),"@Override\n@Retry(retryOn=TimeoutException.class,\n    maxRetries = 4,\n    maxDuration = 10000,\n    delay = 200,\n    jitter = 100,\n    abortOn=InterruptedException.class)\n@Timeout(4000)\npublic void emitWithOffsets(OrderEventBase event, Map<TopicPartition, OffsetAndMetadata> offsetToCommit, String groupID) throws InterruptedException, ExecutionException, TimeoutException {\n    if (kafkaProducer == null) initProducer();\n\n    OrderEvent orderEvent = (OrderEvent)event;\n    String key = ((ShippingOrderPayload)orderEvent.getPayload()).getOrderID();\n    String value = new Gson().toJson(orderEvent);\n    ProducerRecord<String, String> record = new ProducerRecord<>(KafkaInfrastructureConfig.getOrderTopic(), key, value);\n\n    kafkaProducer.beginTransaction();\n    Future<RecordMetadata> send = kafkaProducer.send(record);\n    send.get(KafkaInfrastructureConfig.PRODUCER_TIMEOUT_SECS, TimeUnit.SECONDS);\n    /**\n     * Here is where the consume-transform-produce loop pattern magic happens.\n     * Kafka transactions allow us to commit the offsets read from the consumer as part of the transaction.\n     * That way, both the events produced and the offsets for the records consumed are either both committed or none.\n     * As a result, we ensure no command from the order-commands topic is committed, therefore treated as processed,\n     * unless we produce the resulting event into the order topics, which is the latest of the actions we must complete\n     * for any given command for this microservice. In this case, it will be an OrderCreated, OrderUpdated or OrderRejected event.\n     **/\n    kafkaProducer.sendOffsetsToTransaction(offsetToCommit, groupID);\n    kafkaProducer.commitTransaction();\n}\n")))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-orders-order-mdx-8ab821c008657af0798a.js.map